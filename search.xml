<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础（二）]]></title>
    <url>%2F2019%2F03%2F22%2Fjava-ji-chu-er%2F</url>
    <content type="text"><![CDATA[前言这段时间把基础这部分又过了一遍，归纳整理了有关继承、Object通用方法、关键字的相关知识。 继承访问权限Java中有四种访问权限， 其中三种有访问权限修饰符，分别为private、public、protected，还有一种不带任何修饰符（default）。如果不加访问修饰符，表示包级可见。 protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。 设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。 也就是说只要我是你的子类，继承了你的方法，那就只能比你的访问级别更高。长江后浪推前浪，只有比父亲级别高，才能保证别人只要跟你的父亲合作时就能使用你的资源。 同一个类 同一个包 不同包的子类 不同包的非子类 public √ √ √ √ protected √ √ √ 默认(default) √ √ private √ 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。 public class AccessExample { public String id; } 可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。 public class AccessExample { private int id; public String getId() { return id + &quot;&quot;; } public void setId(String id) { this.id = Integer.valueOf(id); } } 但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。 public class AccessWithInnerClassExample { private class InnerClass { int x; } private InnerClass innerClass; public AccessWithInnerClassExample() { innerClass = new InnerClass(); } public int getValue() { return innerClass.x; // 直接访问 } } 所以总结如下： private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的属性以及方法只能被该类的对象 访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。 protected: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且 允许跨包访问。 抽象类与接口抽象类与接口是java语言中对抽象概念进行定义的两种机制，两者有一定的区别也有很多的相似性。很多常见的面试题都会出诸如抽象类和接口有什么区别，什么情况下会使用抽象类和什么情况你会使用接口 抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。 抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。 public abstract class GenericServlet implements Servlet, ServletConfig, Serializable { // abstract method abstract void service(ServletRequest req, ServletResponse res); void init() { // Its implementation } // other method related to Servlet } public class HttpServlet extends GenericServlet { void service(ServletRequest req, ServletResponse res) { // implementation } protected void doGet(HttpServletRequest req, HttpServletResponse resp) { // Implementation } protected void doPost(HttpServletRequest req, HttpServletResponse resp) { // Implementation } // some other methods related to HttpServlet } 接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。 接口的字段默认都是 static 和 final 的。 当你实现这个接口时，你就需要实现接口的方法。 比较： 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 抽象类可以有构造器，接口不能有构造器。 抽象类的实现：子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 接口的实现：子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 使用选择：接口： 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； 需要使用多重继承。 抽象类： 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。 重写与重载 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。使用 @Override注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 Object 通用方法 Java类层次结构的顶层是Object类，所有的其他类都隐式的继承于它。 public native int hashCode() public boolean equals(Object obj) protected native Object clone() throws CloneNotSupportedException public String toString() public final native Class&lt;?&gt; getClass() protected void finalize() throws Throwable {} public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException 重点方法：equals、hashCode、toString和clone equals()equals()方法实现需要满足以下几个规则限制： 自反性：对象x必须与其自身相等，equals(x)返回true 对称性：如果equals(y)为true，则y.equals(x)也要返回true 传递性：如果equals(y)为true，并且y.equals(z)也为true，则x.equals(z)也要为true 一致性：多次调用equals()方法应该返回相同值，除非对用于判等的任何一个属性进行了修改 与null判等：equals(null)总是要返回false x.equals(x); // true -------自反性 x.equals(y) == y.equals(x); // true -------对称性 if (x.equals(y) &amp;&amp; y.equals(z)) -------传递性 x.equals(z); // true; x.equals(y) == x.equals(y); // true -------一致性 x.equals(null); // false; -------与null判等 等价与相等 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 Integer x = new Integer(1); Integer y = new Integer(1); System.out.println(x.equals(y)); // true System.out.println(x == y); // false hashCode()hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。 为了避免得到不可预期的结果，尽可能在实现equals()和hashCode()方法时使用final字段，从而保证方法的结果不会受到字段变化的影响(尽管真实场景中未必发生)。 最后，要确保在实现equals()和hashCode()方法是使用相同的字段，以确保在不可预期的字段调整时保证这两个方法行为的一致性。 toString()默认情况下，toString()的结果仅仅返回以@符分隔的全类名与对象哈希值串。（ToStringExample@4554617c）其中 @ 后面的数值为散列码的无符号十六进制表示。 clone()clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 clone()方法的目的很简单——返回对象实例的拷贝 注意：clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛 CloneNotSupportedException。 在重载时需要声明为public并把返回值类型调整为重载类自身类型。再次，重载类需要实现Cloneable接口(尽管该接口作为一种声明，并未提供任何方法定义)，否则将会抛出CloneNotSupportedException异常。最后，在实现clone()方法时要先调用super.clone()然后再执行其他需要的动作。 关键字final1.声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 final int x = 1; // x = 2; // cannot assign value to final variable &#39;x&#39; final A y = new A(); y.a = 1; 2.声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3.声明类不允许被继承。 staticstatic表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法,被static修饰的成员变量和成员方法独立于该类的任何对象。 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 public class A { private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) { // int x = A.x; // Non-static field &#39;x&#39; cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; } } 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法 public class A { private static int x; private int y; public static void func1(){ int a = x; // int b = y; // Non-static field &#39;y&#39; cannot be referenced from a static context // int b = this.y; // &#39;A.this&#39; cannot be referenced from a static context } } 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 静态语句块 静态语句块在类初始化时运行一次。 public class A { static { System.out.println(&quot;123&quot;); //123 } public static void main(String[] args) { A a1 = new A(); A a2 = new A(); } } static和final一块用表示什么 static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！ 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。 对于方法，表示不可覆盖，并且可以通过类名直接访问 初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 结语写了这么多，收获也很多。全当一个归纳总结了。看了这么多例子，最重要的是要举一反三，先问是不是，再问为什么。多用，多学。 文中若有不正之处，欢迎批评指正！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础（一）]]></title>
    <url>%2F2019%2F03%2F07%2Fjava-ji-chu-yi%2F</url>
    <content type="text"><![CDATA[Java基础知识点归纳 前言有空就想借着写博客的同时把 Java 相关的个人所学的基础知识做一个梳理整合。内容尽量做到全面，浅显易懂吧，这样既方便自己以后查阅复习，也分享出来给刚刚入门的程序员们，希望可以给大家一些参考，让大家对Java有一个基本的认识，更好的学习Java。 Java基础知识点归纳数据类型数据类型，Java的数据类型主要分为两大： 内置数据类型 引用数据类型 基本数据类型（内置数据类型）内置数据类型总共有八种： byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean/~ 这应该没什么好说的，基本类型就是这八种。不同的数据类型储存不同类型的变量。 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 装箱与拆箱 在 Java 5 之前如果要生成一个数值为10的Integer对象，必须这样进行： Integer i = new Integer(10); 在 Java 5 之后就提供了自动装箱的特性，上面的代码就变成了这样： int i = 10; 这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型： Integer x = 10; // 装箱 int y = x; // 拆箱 简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。 装箱过程是通过调用包装器的valueOf方法实现的，那么new Integer() 与 Integer.valueOf() 之间有什么区别呢？ new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 Integer x = new Integer(10); Integer y = new Integer(10); System.out.println(x == y); // false Integer z = Integer.valueOf(10); Integer k = Integer.valueOf(10); System.out.println(z == k); // true 从上面代码打印出来的情况，我们可以很明显的看到两者的区别。valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} } 编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。 Integer m = 101; Integer n = 101; System.out.println(m == n); // true Integer x = 127; Integer y = 127; System.out.println(x == y); // true Integer a = 128; Integer b = 128; System.out.println(a == b); // false 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 数据转换 Java的变量类型为布尔型boolean；字符型char；整型byte、short、int、long；浮点型float、double。 其中四种整型变量和两种浮点型变量分别对应于不同的精度和范围。 简单数据类型之间的转换又可以分为： 低级到高级的自动类型转换 高级到低级的强制类型转换 包装类过渡类型能够转换 类型由低级到高级分别为(byte，short，char)–&gt;int–&gt;long–&gt;float–&gt;double byte b; int i=b; long l=b; float f=b; double d=b; 上面的语句在 Java 里面可以直接通过，但是将double型变量赋值给float变量，不加强转的话会报错。 引用数据类型（String）String 被声明为 final，因此它不可被继承。 在 Java 8 中，String 内部使用 char 数组存储数据。 public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { /** The value is used for character storage. */ private final char value[]; } value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 public static void main(String[] args) { //定义字符串变量 //String:引用类型,但是一个不可变的字符序列,当被声明那一刻起,就已经决定它的不能给改变 String str = &quot;abc&quot; ;//String str = new String(&quot;abc&quot;) ; appendStr(str) ; System.out.println(str); /// abc } public static void appendStr(String str){ str += &quot;def&quot; ; } String 不可变有几大好处： 可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。所以 String 的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。 String Pool 的需要 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。如果 String 是可变的，那么变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。 安全性 String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。 线程安全 String 不可变性天生具备线程安全，可以在多个线程中安全地使用。String 自己便是线程安全的。 本地安全性 类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。 String, StringBuffer 跟 StringBuilder 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 三者使用情况： 如果字符串不会更改，请使用String类，因为String对象是不可变的。 如果字符串可以更改（例如：字符串构造中的大量逻辑和操作）并且只能从单个线程访问，则使用 StringBuilder 就足够了。 如果字符串可以更改，并且将从多个线程访问，使用 StringBuffer 因为 StringBuffer 是同步的，因此具有线程安全性。 在大部分情况下 StringBuffer &gt; String，StringBuilder &gt; StringBuffer。 字符串常量池 我们带着以下三个问题，去理解字符串常量池： 字符串常量池的设计意图是什么？ 字符串常量池在哪里？ 如何操作字符串常量池？ 字符串常量池的设计思想 字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能 JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化 为字符串开辟一个字符串常量池，类似于缓存区 创建字符串常量时，首先坚持字符串常量池是否存在该字符串 存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中 实现的基础 实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享 运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收 即：“享元模式”，顾名思义 - - - &gt; 共享元素模式。 一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素。 看下列代码： String a = &quot;aaa&quot; ; String b = &quot;aaa&quot; ; System.out.println(a == b ); //true 字符串常量池在哪里 在分析字符串常量池的位置时，首先了解一下堆、栈、方法区： 堆 存储的是对象，每个对象都包含一个与之对应的class JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定 栈 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象) 每个栈中的数据(原始类型和对象引用)都是私有的 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令) 数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失 方法区 静态区，跟堆一样，被所有的线程共享 方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量 答案就是：在Java 7之前，String Pool被放在运行时常量池中，它属于永久代。而在Java 7，String Pool被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError错误。 问题：String str = new String(“abc”) 创建多少个对象？ 1.在常量池中查找是否有”abc”对象 有则返回对应的引用实例 没有则创建对应的实例对象 2.在堆中 new 一个 String(“abc”) 对象 3.将对象地址赋值给str,创建一个引用 答案：如果常量池中没有”abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用。 操作字符串常量池的方式 下面代码中，s1和s2采用new String（）的方式新建了两个不同字符串，而s3和s4是通过s1.intern（）方法取得一个字符串引用。intern（）首先把s1引用的字符串放到String Pool中，然后返回这个字符串引用。因此s3和s4引用的是同一个字符串。 public static void main(String[] args) { String s1 = new String(&quot;aaa&quot;); String s2 = new String(&quot;aaa&quot;); System.out.println(s1 == s2);// false String s3=s1.intern(); String s4=s1.intern(); System.out.println(s3==s4); // true } 当一个字符串调用intern（）方法时，如果String Pool中已经存在一个字符串和该字符串值相等（使用equals（）方法进行确定），那么就会返回String Pool中字符串的引用;否则，就会在String Pool中添加一个新的字符串，并返回这个新字符串的引用。 如果是采用”bbb”的形式创建字符串，会自动地将字符串放入 public static void main(String[] args) { String s5=&quot;bbb&quot;; String s6=&quot;bbb&quot;; System.out.println(s5==s6); // true }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架学习总结]]></title>
    <url>%2F2019%2F02%2F15%2Fspringmvc-kuang-jia-xue-xi-zong-jie%2F</url>
    <content type="text"><![CDATA[SpringMVC框架学习总结 前言在学校就开始学习 Spring MVC，出来工作之后也用了 Spring MVC 开发了几个项目。但是，还没有好好的系统的梳理一下所学的知识，今天有时间就好好的来做个总结吧。 Spring MVC学习笔记什么是MVCSpring MVC是Spring框架的一个模块，Spring MVC和Spring无需通过中间整合层进行整合。Spring MVC是一个基于MVC的web框架。 那什么是 MVC 呢？ MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 控制器（Controller）- 负责转发请求，对请求进行处理。 视图（View） - 界面设计人员进行图形界面设计。 模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。 所以说，MVC 模式将程序划分成了三个组件，模型（Model）用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。视图（View）负责展示数据。 控制器（Controller）处理事件并作出响应（事件包括用户的行为，比如说请求）和数据 Model 上的改变。 用户发起request请求至控制器(Controller)，控制接收用户请求的数据，委托给模型进行处理 控制器通过模型(Model)处理数据并得到处理结果，模型通常是指业务逻辑 模型处理结果返回给控制器 控制器将模型数据在视图(View)中展示，web中模型无法将数据直接在视图上显示，需要通过控制器完成。 控制器将视图response响应给用户，通过视图展示给用户要的数据或处理结果。 Spring MVC核心架构 发起请求到前端控制器 (DispatcherServlet) 前端控制器请求 HandlerMapping 查找 Handler，可以根据xml配置、注解进行查找 处理器映射器 HandlerMapping 向前端控制器返回Handler 前端控制器调用处理器适配器去执行 Handler 处理器适配器去执行 Handler Handler 执行完成给适配器返回 ModelAndView 处理器适配器向前端控制器返回 ModelAndView，ModelAndView 是 Spring MVC 框架的一个底层对象，包括 Model 和 View 前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图 (jsp) 视图解析器向前端控制器返回 View 前端控制器进行视图渲染，视图渲染将模型数据(在 ModelAndView 对象中)填充到 request 域 前端控制器向用户响应结果 通常呢，我们做项目基本上大多数用的是 Spring+SpringMVC+MyBatis三大框架整合的SSM框架，有时间的话再来搭一个简易的框架。在 Spring MVC 中用到了很多的注解，通过注解可以定义控制器等等。下面是一些常用的注解。 结语有些东西用的多就越用越顺手，但是实际操作跟理论方面都要重视，只有知道这个东西的原理才能走的更远。会用很简单的网上也有很多教程之类的东西，但是还是自己总结归纳的才记忆深刻。一味的敲代码并不能脱离码农，多了解核心的东西才会成长。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>JAVA后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架基础知识]]></title>
    <url>%2F2019%2F01%2F31%2Fspring-kuang-jia-ji-chu-zhi-shi%2F</url>
    <content type="text"><![CDATA[Spring框架基础知识 前言首先有一个问题，什么是 Spring 呢？Spring 啊，它是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。企业级开发 JavaEE 框架有很多，经过一系列的技术变迁，现在应该绝大部分企业开发都是用的 Spring 框架了吧，之所以要用 Spring 进行开发，肯定是因为优点多啊。因为优点多，所以我们需要去了解它，熟悉它，精通它。 Spring框架概述什么是SpringSpring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。任何 Java 应用都可以从 Spring 中受益。Spring 的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring 是一个分层的 JavaSE/EE full-stack(一站式) 轻量级开源框架。 1、轻量级：与EJB对比，依赖资源少，销毁的资源少。 2、一站式，每一个层都提供的解决方案 Spring核心Spring 面向方面编程（AOP）和控制反转 （IOC） 容器 Spring优点 1、方便解耦，简化开发 （高内聚低耦合），使用Spring的IOC容器，将对象之间的依赖关系交给Spring，让我们更专注于应用逻辑 2、Spring就是一个大工厂（容器），可以将所有对象创建和依赖关系维护，交给Spring管理 3、对主流的框架提供了很好的集成支持，如Hibernate,Struts2,JPA等 4、Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 5、Spring的高度可开放性，并不强制依赖于Spring，开发者可以自由选择Spring部分或全部 Spring体系结构Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，如图所示。 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 看了 Spring 是什么，我们再来看看 Spring 的两大核心。 Spring 两大核心 IOC 跟 AOPSpring依赖注入和控制反转的理解Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了” 谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。 DI—Dependency Injection，即“依赖注入”：由容器动态的将某个依赖关系注入到组件之中。理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么” 谁依赖于谁：当然是应用程序依赖于IoC容器； &emsp;为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； &emsp;谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； &emsp;注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 &emsp;&emsp;2004年，大师级人物 Martin Fowler 给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 &emsp;&emsp;当初学习 Spring 的时候看过很多对 Spring 的 IOC 的理解的文章，官方文档也看过。实际上开发过程中自己是实操过，但是对这个控制反转还是一头雾水，在慕课上看了一篇学习笔记，对作者的这种解释比较满意，清楚的解释了什么是控制，什么是反转，谁依赖谁，谁注入谁。 面向切面编程AOP什么是AOP呢？我们常说：“这件事情要从几个方面来看待”，往往意思是：需要从不同的角度来看待同一个事物。这里的“方面”，指的是事物的外在特性在不同观察角度下的体现。而在AOP中，Aspect的含义，可能更多的理解为“切面”比较合适。这在程序开发上就是：通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 主要功能：&emsp;&emsp;日志记录，性能统计，安全控制，事务处理，异常处理等等。 什么时候用到AOP呢？拿我前面做过的一个项目举个例子吧，做的是一个公司的订餐系统，这个系统需要用到Shiro鉴权。项目里面很多的接口，但是有的接口不需要鉴权就可以访问了，是开放的。但是还有一些接口，需要特定权限的用户才能访问，比如说公司的领导的权限跟员工的权限不一样，还有系统管理员。 如果要用 OOP 处理的话，必须在对应的接口代码里面，一个一个写上鉴权的代码。 但是如果使用了AOP之后，写一个接口，在需要鉴权的接口上面添加一个注解即可解决了。这样的做法，对原有代码毫无入侵性，这就是AOP的好处了，把和主业务无关的事情，放到代码外面去做。 上面的例子。给 listCanteenOrders() 方法加入鉴权采用了代理模式。代理模式就是：写了新的接口，去代理一个一个鉴权的代码鉴权。 代理分为静态代理和动态代理，静态代理，顾名思义，就是你自己写代理对象，动态代理，则是在运行期，生成一个代理对象。 Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象。 AOP常用的还有在日志打印跟事务处理方面应用的比较多。 AOP的优点 AOP 是一个概念，一个规范，本身并没有设定具体语言的实现，这实际上提供了非常广阔的发展的空间。 AOP 同时还可以让我们层次化功能性而不是嵌入功能性，从而使得代码有更好的可读性和易于维护。 AOP 让我们在进行系统架构和模块设计的时候多了新的选择和新的思路。 结语面向过程编程已经成为了过去式，面向对象编程正在一统软件开发世界。而 Spring 是独特的、优秀的。今天有时间梳理一遍关于 Spring 的有关知识还是收获颇多，许多知识也是以往的自己所不知道的。关于 Spring 的学习还远远没有结束。学习的最好的方法就是尝试，积累足够的项目经验，才能在需要用到时候信手拈来，继续努力吧！]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>JAVA后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+hexo 搭建属于自己的一个博客]]></title>
    <url>%2F2019%2F01%2F28%2Fgithub-hexo-da-jian-shu-yu-zi-ji-de-yi-ge-bo-ke%2F</url>
    <content type="text"><![CDATA[技术小白搭建个人博客&emsp;—— hexo+github 前言为什么要搭建一个自己的博客呢？ 因为是个技术小白，然后经常在网上浏览各种技术博客，总面临一个问题。那就是每次看过之后就忘了，回过头来感觉还是没学到什么，就像做无用功一样。俗话说好记性不如烂笔头，于是决定了。作为一个程序猿，当然也得有一个记录自己学习工作的一个博客咯！于是谷歌一下，看了一会儿，于是决定采用 Github+hexo 搭建一个属于自己的博客。 这里说一下为什么选择 Github+hexo 搭建的几点原因： 1 当然是因为穷啦，Github免费的 2 快速搭建，全程走下来只要差不多一个小时就可以搭建成功了 3 全静态，支持MarkDown,静态博客最大的优势就是没有数据库，可以很方便的迁移，也不用担心安全问题 开始搭建1 软件安装配置搭建博客，首先需要安装环境，这里需要两个软件：Git和Nodejs。 Git安装 网址：https://git-scm.com/download/win Node.js安装 网址：https://nodejs.org/en/download/ 安装完成之后，要确认自己是否安装成功，打开cmd运行下面的命令，有返回信息就是成功的了。 git –versionnode -vnpm -v 2 安装hexo我个人习惯把相关的软件安装在一起，所以新建一个文件夹用来安装hexo,新建一个文件夹 hexo博客 然后打开这个文件夹，刚刚安装成功了git,在空白地方点击右键，选择 Git bash here 利用npm命令安装hexo npm install hexo-cli -g 安装完成之后，关掉Git Bash 窗口，然后在hexo博客 文件夹下面新建一个文件夹，这个文件夹就是放hexo跟你以后写的博客的文件夹，名字随便你自己取，我的叫username.github.io 进入刚刚你新建的这个文件夹，同样里面什么都没有，然后右键空白地方，选择 Git bash here ，执行安装hexo的命令。 hexo init 安装依赖包 npm install git部署安装 npm install hexo-deployer-git –save 到了这里，该安装的已经安装好了，接下来就看看成果吧。 hexo ghexo s 到浏览器输入 localhost:4000就可以看到页面内容了。这个时候看到的是一篇默认的博客：Hello World。 3 把博客部署到Github Pages上去 完成了上面的工作，我们已经可以写自己的博客了，但是呢，博客只能在自己的本地看得到，别人无法在网上查看你的博客。接下来我们就要结合Github page的功能让别人也能看到你的博客。 如果你没有github的话，首先需要注册一个github，访问github，点击右上角的注册。uername 最好都用小写，因为最后建立的博客地址是：http://username.github.io 邮箱十分重要，GitHub 上很多通知都是发送到你的邮箱的。 创建Repository代码仓库Repository 名字应该是username.github.io。username 就是 你注册时候的 username。点击creat repository 仓库建好了，接下来就需要把本地的代码放到这个仓库里面。 首先检查自己的电脑上面有没有SSH Key,打开cmd输入下面命令: cd ~/. ssh 如果返回“No such file or directory”，说明你的电脑上面没有SSH Key。 生成新的SSH Key 第一步、创建一对新的SSH密钥(keys) ssh-keygen -t rsa -C “邮件地址@youremail.com” 输入回车之后系统会要你输入密码： Enter passphrase (empty for no passphrase):&lt;设置密码&gt;Enter same passphrase again:&lt;再次输入密码&gt; 【提示】输入密码的时候，密码是看不见的，不要慌！ 输入完成后会出现： Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 第二步、在GitHub中添加你的公钥 运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。 clip &lt; ~/.ssh/id_rsa.pub 接下来： 1.登陆GitHub,进入你的Account Settings。 2.选择SSH Keys 3.粘贴密钥，添加即可 添加好之后我们还需要测试一下添加的东西有没有效果。 进入hexo博客这个文件夹，右键空白，然后选择Git bash here，输入下面的命令： ssh -T git@github.com 返回： The authenticity of host ‘GitHub.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no) 输入 yes 之后证明添加的东西已经起了效果，接下来我们还需要设置一点东西： $ git config –global user.name “wuyalan”//输入注册时的username$ git config –global user.email “alan.wyl@foxmail.com“//填写注册邮箱 git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。 第三步、将本地的Hexo文件更新到Github的库中 上面我们已经把本机跟github的连接通道打通了，现在就是把本地的东西放到我们建的仓库里面去。 1.登录Github打开自己的项目 username.github.io 2.第二步、打开之后，点击SSH，选择SSH类型地址 3.第三步、复制地址 4.第四步、打开一开始创建的hexo博客文件夹，用记事本打开刚文件夹下的_config.yml文件 5.第五步、在配置文件里作如下修改，保存 deploy:&emsp;&emsp;type: git&emsp;&emsp;repository: git@github.com:username/username.github.io.git&emsp;&emsp;branch: master 6.第六步、在Hexo文件夹下Git bash here界面执行： hexo ghexo d 执行完之后会让你输入github的密码，输入完后就可以把自己的代码上传到GitHub上面了。如果报错： ERROR Deployer not found: git，那么就是你的deployer没有安装成功，你需要执行如下命令再安装一次： npm install hexo-deployer-git –save 一切正常之后就可以打开浏览器，输入 username.github.io查看了，这个username就是前面建好的那个。如果得到你想要的效果，那么恭喜你，博客已经搭建好啦！每一个人都可以通过这个地址访问到你的博客了。 接下来你就可以随心所欲的写各种属于自己的博客啦，是不是很酷啊。全程走下来大概花费时间在一个小时左右。当然了，搭建不费什么事情，就是有很多坑注意避免一下就行了，具体原因可以谷歌解决哈~！ 结语搭建了属于自己的博客，还是有一定的成就感的。也把自己搭建的过程写出来了，当然第一次写博客还有很多地方不足，虽然内容不是很多，但是写的时间也很长。其实博客远不止于此，会搭建之后你还得会写，使用 MarkDown 进行编写，我推荐使用Markdown Pad2，我也是使用的这款软件。博客的样子还很丑，以后有时间再来慢慢美化。以后的路还很长，所以要认真写博客，记录自己的成长。 如果有什么问题的话，可以通过我博客的联系方式联系我，也欢迎大家一起交流，一起学习进步。 以下一些工具及学习连接： Markdown Pad2：https://pan.baidu.com/s/1JR_0OCoaM98IlAK67KocUw &emsp;提取码：xqao Markdown——入门指南 使用next主题配置博客基本信息 hexo的next主题个性化配置教程 让你的Hexo博客华丽升级]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
